// This file generated by AnterleTool.
// Dont modifiy it.
// clang-format off

#include "scripting/glm/generated/vectors/vec2.hpp"

namespace Andterle::Scripting {
void bind_vec2(sol::state &lua)
{
auto multiplication_overloads = sol::overload(
    [](const glm::vec2 &v1, glm::vec2 v2) { return v1 * v2; },
    [](const glm::vec2 &v1, float v2) { return v1 * v2; },
    [](const float &v1, glm::vec2 v2) { return v1 * v2; }
);
auto division_overloads = sol::overload(
    [](const glm::vec2 &v1, glm::vec2 v2) { return v1 / v2; },
    [](const glm::vec2 &v1, float v2) { return v1 / v2; },
    [](const float &v1, glm::vec2 v2) { return v1 / v2; }
);
auto addition_overloads = sol::overload(
    [](const glm::vec2 &v1, glm::vec2 v2) { return v1 + v2; },
    [](const glm::vec2 &v1, float v2) { return v1 + v2; },
    [](const float &v1, glm::vec2 v2) { return v1 + v2; }
);
auto subtraction_overloads = sol::overload(
    [](const glm::vec2 &v1, glm::vec2 v2) { return v1 - v2; },
    [](const glm::vec2 &v1, float v2) { return v1 - v2; },
    [](const float &v1, glm::vec2 v2) { return v1 - v2; }
);
    lua.new_usertype<glm::vec2>("vec2",
        sol::call_constructor,
        sol::constructors<glm::vec2(float), glm::vec2(float, float)>(),
        "x", &glm::vec2::x,
        "y", &glm::vec2::y,
        "r", &glm::vec2::r,
        "g", &glm::vec2::g,
        "s", &glm::vec2::s,
        "t", &glm::vec2::t,
        sol::meta_function::multiplication, multiplication_overloads,
        sol::meta_function::division, division_overloads,
        sol::meta_function::addition, addition_overloads,
        sol::meta_function::subtraction, subtraction_overloads,
        "length", [](const glm::vec2 &v) { return glm::length(v); }
    );
}
}// namespace Andterle::Scripting
// clang-format on
